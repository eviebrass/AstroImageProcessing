import numpy as np
import matplotlib.pyplot as plt
from astropy.io import fits
import pickle
from scipy.optimize import curve_fit

#%% Don't run this file all the time
# Check the contents of the FITS file
hdulist = fits.open('A1_mosaic.fits')
with open('hdulist.pickle', 'wb') as f:
    pickle.dump(hdulist[0].data, f)
#%%
with open('hdulist.pickle', 'rb') as f:
    data = pickle.load(f)

print(np.shape(data))
print(type(data))

#### SEE THE IMAGE ######
plt.imshow(data, cmap='gray')
plt.colorbar()
plt.show()
#### CROPPING THE EDGES OF THE IMAGE ######
edge_val = data[0][0]
# find the height of the border
for i in range(len(data[100][:])):
    if data[100][i] == edge_val:
        continue
    elif data[100][i] != edge_val:
        height = i + 100
        break
# find the width of the border
for i in range(len(data[:][100])):
    if data[i][100] == edge_val:
        continue
    elif data[i][100] != edge_val:
        width = i + 100
        break

#cropping picture 
#data = data[width:4610-width][height:2569-height]
data = data[width:4610-width,height:2569-height]
print('Shape of cropped image:', np.shape(data))

# save the new file data
fits.writeto('cropped_image.fits', data, overwrite=True)

#### SEE THE IMAGE ######
plt.imshow(data, cmap='gray')
plt.colorbar()
plt.show()
#%%### PLOTTING A HISTOGRAM OF THE PIXEL COUNTS ######
data_flat = np.ravel(data) # change into one long list of the data
# find the histogram points
hist_y, hist_edges = np.histogram(data_flat, bins=2000)  
hist_centers = 0.5*(hist_edges[1:] + hist_edges[:-1])
hist_error = np.sqrt(hist_y)
# curve_fit a Gaussian
def gaussian(data, A, mean, sigma):
    return A*np.exp(-1*(data - mean)**2 / (2*sigma*sigma))
hist_fit, hist_cov = curve_fit(gaussian, hist_centers, hist_y, p0=[7e6,3420,18])
x_hist_fit = np.linspace(3300, 3650, 1000)
plt.plot(x_hist_fit, gaussian(x_hist_fit, *hist_fit), color='black', label = 'gaussian fit')
plt.errorbar(hist_centers, hist_y, yerr= hist_error,color='red', fmt='x')
plt.hist(data_flat, bins=2000, label ='Pixel Counts')
plt.xlim(3300,3650) #zoom into background (5000 bins used)
# plt.ylim(0,20)
# plt.xlim(30000,66000) #zoom into edge of  upper tail
plt.legend()
plt.show()

background_count = hist_fit[1]
background_spread = hist_fit[2]

#%%### MASKING ARRAY ######
mask_array = np.ones(np.shape(data)) # initially all 1's
print('shape of initial masked array:', np.shape(mask_array))

# function to remove star like shapes
def remove_star(x_center, y_center,r, x1_rect, x2_rect, y1_rect, y2_rect):
    ''' Takes in the dimensions of the shapes you want to remove
    centers refers to the circle mask, r is the radius of this circle
    READ OFF THE X AND Y POSITIONS FROM DS9, THIS CODE SHOULD FLIP THEM FOR YOU'''
    # remove the circular part
    for px in range(4172):
        for py in range (2135):
            x_mag = (px - y_center) * (px - y_center)
            y_mag = (py - x_center) * (py - x_center)
            r_sq = r * r
            if x_mag + y_mag < r_sq:
                mask_array[px, py] = 0
    # remove the rectangular part
    mask_array[y1_rect:y2_rect, x1_rect:x2_rect] = 0

remove_star(1200, 3000, 200,1210, 1230, 0, -1)
remove_star(558, 3105, 40, 555, 561, 2980, 3198)
remove_star(757, 2555, 35, 753, 760, 2484, 2616)
remove_star(687, 2066, 40, 684, 691, 2003, 2136)
remove_star(1917, 3540, 25, 1915, 1920, 3487, 3582)
 
# Remove the triangles in the shape
def remove_triangle(x1, y1, x2, y2, x3, y3, x1_rect, x2_rect, y1_rect, y2_rect):
    # gradients of each side of the triangle
    m1 = (x3 - x1) / (y3 - y1)
    m2 = (x3 - x2) / (y3 - y2)
    # constants for each straight line
    c1 = x1 - m1 * y1
    c2 = x2 - m2 * y2
    c3 = y1
    # finding the triangle thing itself
    for px in range(4172):
        for py in range (2135):
            if py > m1*px + c1 and py < m2*px + c2 and px > y1:
                mask_array[px, py] = 0
    mask_array[y1_rect:y2_rect, x1_rect:x2_rect] = 0
    
remove_triangle(1161, 0, 1275, 0, 1222, 57,0 , 0 , 0 , 0) 
remove_triangle(1121, 103, 1287, 103, 1227, 171, 803, 1487, 95, 104)
remove_triangle(1124, 216, 1303, 216, 1220, 274, 887, 1434, 207, 217)

# removing other random points at the bottom
mask_array[207:210, 810:826] = 0
mask_array[205:232, 819:822] = 0
mask_array[114:135, 1424:1431] = 0

print('shape of mask array after removed bleeding:', np.shape(mask_array))
           
data_no_bleed = mask_array * data
print('shape of data_no_bleed:', np.shape(data_no_bleed))

fits.writeto('no_bleed_data.fits', data_no_bleed, overwrite=True)

#%%### GET RID OF DATA THAT WE DEEM TO BE BACKGROUND ######

background_cut_off = background_count + 3 * background_spread # Three sigma above the wanted value
# remove points below our maximum value

# remove points below our maximum value
min_i = np.array(np.where(data_no_bleed <= background_cut_off))
x_min_i = min_i[0,:]
y_min_i = min_i[1,:]
for j in range(len(x_min_i)):
        mask_array[x_min_i[j],y_min_i[j]] = 0
        
data_final = mask_array * data_no_bleed
fits.writeto('data_final.fits', data_final, overwrite=True)
plt.imshow(data_final, cmap='gray')
plt.colorbar()
plt.show()

#%% PRINTING THE USEFUL VALUES
print(f'{background_count= :.5f}')
print(f'{background_spread= :.5f}')
